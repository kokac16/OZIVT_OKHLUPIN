Отчет по Теме #9 выполнил(а):
- Охлупин Константин Алексеевич
- ИВТ-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + |   |
| Задание 3 | + |   |
| Задание 4 | + |   |
| Задание 5 | + |   |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа 
### 1) Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте  класс,  указав  в  свойствах  только  имя.  Дальше  создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав  атрибут,  который  не  указан  в  вашем  классе,  например, попробуйте вызвать фамилию.

```python
class Ivan:
    ___slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"
person1 = Ivan ('Алкесей')
person2 = Ivan ('Иван')
print (person1.name)
print(person2.name)

person2.surname = 'Петров'
```
### Результат.
![ex1](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Lab/91.png)

## Выводы
Класс "Ivan" имеет конструктор "init", принимающий параметр "name". Если "name" равно "Иван", атрибут "name" устанавливается в "Да, я Иван", иначе в "Я не [введенное имя], а Иван". Создаются объекты "person1" с именем "Алексей" и "person2" с именем "Иван". Выводятся значения атрибута "name" для обоих объектов. В строке "person2.surname = 'Петров'" происходит ошибка, так как атрибут "surname" не определен в классе "Ivan".



### 2) Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет  определяться  изменили  ли  состав  мороженого  или  нет.  В  этом классе  реализуйте  метод,  выводящий  на  печать  «Мороженое  с {ТОППИНГ}»  в  случае  наличия  добавки,  а  иначе  отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
    def __init__(self, ingredient=None): 
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print (f"Mopoжeноe c {self.ingredient}")
        else:

            print('Обычное мороженое')


icecream = Icecream() 
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```

### Результат.
![ex2](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Lab/92.png)

## Выводы
Конструктор "init" принимает параметр "ingredient" и проверяет, является ли он строкой. Если это так, то атрибут "ingredient" объекта класса "Icecream" устанавливается в значение параметра "ingredient". В противном случае, атрибут "ingredient" устанавливается в значение None.
Функция "composition" проверяет, есть ли значение атрибута "ingredient" объекта. Если значение есть, то выводится сообщение с указанием ингредиента. В противном случае, выводится сообщение "Обычное мороженое".


### 3) Петя – начинающий программист и на занятиях ему сказали реализовать икапсу...что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу...что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также  вас  необходимо  объяснить  Пете  почему  на  скриншоте  ниже  в консоли выводится ошибка. 

```python
class MyClass:
    def __init__(self, value): 
        self._value = value

    def set_value(self, value): # yстановка значения атрибута 
        self._value = value

    def get_value(self): # получение значения атрибута
        return self._value

    def del_value(self): # удаление атрибута
        del self._value


    value = property(get_value, set_value, del_value, "Свойство value")
obj = MyClass(42) 
print(obj.get_value()) 
obj.set_value(45) 
print(obj.get_value()) 
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```

### Результат.
![ex3](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Lab/93.png)

## Выводы
Конструктор "init" принимает параметр "value" и устанавливает атрибут "_value" объекта класса равным значению параметра.
Функция "set_value" принимает параметр "value" и устанавливает атрибут "_value" объекта класса в значение параметра.
Функция "get_value" возвращает значение атрибута "_value" объекта класса.
Функция "del_value" удаляет атрибут "_value" объекта класса.
Затем, используя декоратор "property", создается свойство "value", которое использует функции "get_value", "set_value" и "del_value" для получения, установки и удаления значения атрибута "_value" соответственно.


### 4) Вам  прекрасно  известно,  что  кошки  и  собаки  являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи Михаил А. Панов“наследования”  объяснить  компьютеру  что  кошки  и  собаки  –  это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга. 

```python
class Mammal: 
    className = 'Mammal'

class Dog (Mammal): 
    species = 'canine'
    sounds = 'wow'

class Cat (Mammal):
    species = 'feline'
    sounds = 'meow'
    

dog = Dog()
print (f"Dog is {dog.className}, but they say {dog.sounds}") 
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### Результат.
![ex4](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Lab/94.png)

### Выводы
Mammal - базовый класс для млекопитающих с атрибутом className равным "Mammal".
Dog - класс для собак, наследуется от класса Mammal, имеет атрибуты species (вид) равный "canine" и sounds (звук) равный "wow".
Cat - класс для кошек, также наследуется от класса Mammal, с атрибутами species равным "feline" и sounds равным "meow".
Создаются экземпляры классов Dog и Cat, и выводится информация о них, включая имя класса и звук, который они издают.


### 5)На  разных  языках  здороваются  по-разному,  но  суть  остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть  первого  предложения  задачи.  Для  этого  мы  можем  выбрать  два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих  языках.  А  также  напишем  функцию,  которая  будет  выводить информацию о том, как на этих языках здороваются.  Заметьте,  что  для  решения  поставленной  задачи  мы  использовали декоратор  @staticmethod,  поскольку  нам  не  нужны  обязательные параметры-ссылки вроде self.


```python
class Russian:
    @staticmethod
    def greeting(): 
        print("Привет")

class English:
    @staticmethod 
    def greeting(): 
        print("Hello")

def greet (language): 
    language.greeting()


ivan = Russian()
greet (ivan)
john =  English()
greet (john)

```

### Результат.
![ex5](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Lab/95.png)

### Выводы
Russian и English - классы с методом greeting, который выводит приветствие на русском и английском соответственно, с использованием декоратора @staticmethod.
greet(language) - функция, принимающая объект language в качестве аргумента и вызывающая его метод greeting.
ivan - экземпляр класса Russian, john - экземпляр класса English.
Вызываются функции greet(ivan) и greet(john), выводя приветствия на русском и английском соответственно.

## Самостоятельная работа 
### 1) Задание Садовник и помидоры.

```python
class Tomato:
    # 1) Создайте класс Tomato
    # 2) Создайте статическое свойство states, которое будет содержать все
    # стадии созревания помидора
    states = ['отсутствует', 'цветение', 'зеленый', 'красный']

    # 3) Создайте метод __init__(), внутри которого будут определены два
    # динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states).
    # После написания этого блока кода в комментарии к нему укажите какими являются
    # эти два свойства
    def __init__(self, index):
        self._index = index  # _index - динамическое свойство, передается параметром
        self._state = self.states[0]  # _state - динамическое свойство, принимает первое значение из списка states

    # 4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания
    def grow(self):
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    # 5) Создайте метод is_ripe(), который будет проверять, что томат созрел
    def is_ripe(self):
        return self._state == self.states[-1]


class TomatoBush:
    # 1) Создайте класс TomatoBush
    def __init__(self, num_tomatoes):
        # 2) Определите метод __init__(), который будет принимать в качестве
        # параметра количество томатов и на его основе будет создавать
        # список объектов класса Tomato. Данный список будет храниться
        # внутри динамического свойства tomatoes
        self.tomatoes = [Tomato(index=i) for i in range(1, num_tomatoes + 1)]

    # 3) Создайте метод grow_all(), который будет переводить все объекты
    # из списка томатов на следующий этап созревания
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # 4) Создайте метод all_are_ripe(), который будет возвращать True, если
    # все томаты из списка стали спелыми.
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    # 5) Создайте метод give_away_all(), который будет чистить список
    # томатов после сбора урожая
    def give_away_all(self):
        self.tomatoes = []


class Gardener:
    # 1) Создайте класс Gardener
    # 2) Создайте метод __init__(), внутри которого будут определены два
    # динамических свойства: name (передается параметром, является
    # публичным) и _plant (принимает объект класса TomatoBush).
    # После написания этого блока кода в комментарии к нему укажите какими
    # являются эти два свойства
    def __init__(self, name, plant):
        self.name = name  # name - динамическое свойство, передается параметром, публичное
        self._plant = plant  # _plant - динамическое свойство, принимает объект класса TomatoBush

    # 3) Создайте метод work(), который заставляет садовника работать, что
    # позволяет растению становиться более зрелым
    def work(self):
        self._plant.grow_all()

    # 4) Создайте метод harvest(), который проверяет, все ли плоды созрели.
    # Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
    def harvest(self):
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()
        else:
            print("Плоды еще не все созрели. Подождите немного.")

    # 5) Создайте статический метод knowledge_base(), который выведет в
    # консоль справку по садоводству
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: чето инфа про помидоры")


# Тесты:
# 1) Вызовите справку по садоводству
Gardener.knowledge_base()

# 2) Создайте объекты классов TomatoBush и Gardener
bush = TomatoBush(num_tomatoes=10)
gardener = Gardener(name="Иван", plant = bush)

# 3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
gardener.work()

# 4) Попробуйте собрать урожай, когда томаты еще не дозрели.
# Продолжайте ухаживать 6за ними
gardener.harvest()
gardener.work()

# 5) Соберите урожай
gardener.harvest()

```
### Результат.
![ex1](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Practic/91.png)
![ex1](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Practic/92.png)
![ex1](https://github.com/kokac16/OZIVT_OKHLUPIN/blob/theme_9/pic/Practic/93.png)



## Общий вывод по теме
Определение класса: Класс представляет собой шаблон для создания объектов, объединяя в себе атрибуты и методы.
Атрибуты класса: Это переменные, хранящие информацию о состоянии объекта.
Методы класса: Определенные функции внутри класса, обрабатывающие его атрибуты и реализующие функциональность объекта.
Создание экземпляров класса: Процесс создания объектов на основе класса.
Свойства экземпляров класса: Переменные, привязанные к конкретному объекту.
Модификация свойств: Возможность изменять состояние экземпляра класса.
Уникальность экземпляров: Каждый экземпляр имеет уникальные характеристики.
Динамическое изменение: Возможность добавления новых атрибутов и методов к классу во время выполнения программы.
Статические методы: Методы, связанные с классом, но не имеющие доступа к его экземплярам.
Классовые методы: Методы, работающие с классом, но не привязанные к конкретному экземпляру
Сокрытие информации: Принцип, который позволяет скрывать детали реализации и предоставлять только необходимый интерфейс.
Контроль доступа: Управление доступом к атрибутам и методам класса, определяющее, какие из них видны извне.
Капсуляция данных: Упаковка данных и методов, работающих с ними, в единый объект.
Наследование
Классы-родители и классы-потомки: Возможность создавать новый класс на основе существующего, наследуя его атрибуты и методы.
Наследование атрибутов и методов: Перенос характеристик и функциональности от родительского класса к потомку.
Переопределение методов: Возможность изменять реализацию унаследованных методов в дочерних классах.
Добавление новых атрибутов и методов: Расширение функционала дочернего класса без изменения родительского.
Иерархия классов: Организация классов в структуру, отражающую отношения "родитель-потомок".
Зависимость между классами: Отношение, когда один класс использует другой, но не наследует его.
Взаимодействие через методы и атрибуты: Объекты классов взаимодействуют друг с другом через их методы и атрибуты.
Различные типы ассоциаций: Включает агрегацию (слабая связь) и композицию (сильная связь).
Основные аспекты полиморфизма: Возможность объектов разных классов обладать одинаковым интерфейсом.
Переопределение методов: Различные классы могут предоставлять свою версию одного и того же метода.
Абстрактные классы и интерфейсы: Использование абстрактных классов и интерфейсов для определения общих стандартов, которым должны соответствовать классы.





